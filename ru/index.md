# Проект ввода / вывода: создание программы командной строки

Эта глава представляет собой резюме многих навыков, которые вы изучили до сих пор, и исследование еще нескольких стандартных функций библиотеки. Мы создадим инструмент командной строки, который взаимодействует с файлами и вводом / выводом командной строки, чтобы попрактиковаться в некоторых концепциях Rust, которые у вас сейчас есть.

Скорость, безопасность, единый двоичный вывод и межплатформенная поддержка Rust делают его идеальным языком для создания инструментов командной строки, поэтому для нашего проекта мы создадим собственную версию классического инструмента командной строки `grep` ( **g** lobally search a **r** Регулярные **й** Xpression и **р** ечать). В простейшем случае `grep` ищет в указанном файле указанную строку. Для этого `grep` принимает в качестве аргументов имя файла и строку. Затем он читает файл, находит в этом файле строки, содержащие строковый аргумент, и печатает эти строки.

Попутно мы покажем, как заставить наш инструмент командной строки использовать функции терминала, которые используются многими инструментами командной строки. Мы прочтем значение переменной среды, чтобы пользователь мог настроить поведение нашего инструмента. Мы также будем печатать сообщения об ошибках в стандартный поток консоли ошибок ( `stderr` ) вместо стандартного вывода ( `stdout` ), поэтому, например, пользователь может перенаправить успешный вывод в файл, все еще видя сообщения об ошибках на экране.

Один из участников сообщества Rust, Эндрю Галлант, уже создал полнофункциональную, очень быструю версию `grep` , которая называется `ripgrep` . Для сравнения, наша версия `grep` будет довольно простой, но эта глава даст вам некоторые `ripgrep` знания, необходимые для понимания реального проекта, такого как `ripgrep` .

Наш проект `grep` объединит несколько концепций, которые вы уже изучили:

- Организация кода (используя то, что вы узнали о модулях в [главе 7] <!-- игнорировать --> )
- Использование векторов и строк (сборники, [глава 8] <!-- игнорировать --> )
- Обработка ошибок ( [Глава 9] <!-- игнорировать --> )
- Использование признаков и продолжительности жизни там, где это необходимо ( [глава 10] <!-- игнорировать --> )
- Написание тестов ( [Глава 11] <!-- игнорировать --> )

Мы также кратко представим замыкания, итераторы и объекты признаков, которые главы [13] <!-- игнорировать --> и [17] <!-- игнорировать --> расскажу подробно.


[главе 7]: ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
[глава 8]: ch08-00-common-collections.html
[Глава 9]: ch09-00-error-handling.html
[глава 10]: ch10-00-generics.html
[Глава 11]: ch11-00-testing.html
[13]: ch13-00-functional-features.html
[17]: ch17-00-oop.html